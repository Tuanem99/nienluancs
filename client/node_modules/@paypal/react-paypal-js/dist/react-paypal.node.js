'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/*!
 * paypal-js v3.1.11 (2021-06-03T21:16:51.218Z)
 * Copyright 2020-present, PayPal, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function findScript(url, attributes) {
  var currentScript = document.querySelector("script[src=\"" + url + "\"]");
  if (currentScript === null) return null;
  var nextScript = createScriptElement(url, attributes); // ignore the data-uid-auto attribute that gets auto-assigned to every script tag

  var currentScriptDataset = Object.assign({}, currentScript.dataset);
  delete currentScriptDataset.uidAuto; // check if the new script has the same number of data attributes

  if (Object.keys(currentScriptDataset).length !== Object.keys(nextScript.dataset).length) {
    return null;
  }

  var isExactMatch = true; // check if the data attribute values are the same

  Object.keys(currentScriptDataset).forEach(function (key) {
    if (currentScriptDataset[key] !== nextScript.dataset[key]) {
      isExactMatch = false;
    }
  });
  return isExactMatch ? currentScript : null;
}

function insertScriptElement(_a) {
  var url = _a.url,
      attributes = _a.attributes,
      onSuccess = _a.onSuccess,
      onError = _a.onError;
  var newScript = createScriptElement(url, attributes);
  newScript.onerror = onError;
  newScript.onload = onSuccess;
  document.head.insertBefore(newScript, document.head.firstElementChild);
}

function processOptions(options) {
  var sdkBaseURL = "https://www.paypal.com/sdk/js";

  if (options.sdkBaseURL) {
    sdkBaseURL = options.sdkBaseURL;
    delete options.sdkBaseURL;
  }

  var processedMerchantIDAttributes = processMerchantID(options["merchant-id"], options["data-merchant-id"]);
  var newOptions = Object.assign({}, options, processedMerchantIDAttributes);

  var _a = Object.keys(newOptions).filter(function (key) {
    return typeof newOptions[key] !== "undefined" && newOptions[key] !== null && newOptions[key] !== "";
  }).reduce(function (accumulator, key) {
    var value = newOptions[key].toString();

    if (key.substring(0, 5) === "data-") {
      accumulator.dataAttributes[key] = value;
    } else {
      accumulator.queryParams[key] = value;
    }

    return accumulator;
  }, {
    queryParams: {},
    dataAttributes: {}
  }),
      queryParams = _a.queryParams,
      dataAttributes = _a.dataAttributes;

  return {
    url: sdkBaseURL + "?" + objectToQueryString(queryParams),
    dataAttributes: dataAttributes
  };
}

function objectToQueryString(params) {
  var queryString = "";
  Object.keys(params).forEach(function (key) {
    if (queryString.length !== 0) queryString += "&";
    queryString += key + "=" + params[key];
  });
  return queryString;
}

function createScriptElement(url, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }

  var newScript = document.createElement("script");
  newScript.src = url;
  Object.keys(attributes).forEach(function (key) {
    newScript.setAttribute(key, attributes[key]);

    if (key === "data-csp-nonce") {
      newScript.setAttribute("nonce", attributes["data-csp-nonce"]);
    }
  });
  return newScript;
}

function processMerchantID(merchantID, dataMerchantID) {
  var newMerchantID = "";
  var newDataMerchantID = "";

  if (Array.isArray(merchantID)) {
    if (merchantID.length > 1) {
      newMerchantID = "*";
      newDataMerchantID = merchantID.toString();
    } else {
      newMerchantID = merchantID.toString();
    }
  } else if (typeof merchantID === "string" && merchantID.length > 0) {
    newMerchantID = merchantID;
  } else if (typeof dataMerchantID === "string" && dataMerchantID.length > 0) {
    newMerchantID = "*";
    newDataMerchantID = dataMerchantID;
  }

  return {
    "merchant-id": newMerchantID,
    "data-merchant-id": newDataMerchantID
  };
}
/**
 * Load the Paypal JS SDK script asynchronously.
 *
 * @param {Object} options - used to configure query parameters and data attributes for the JS SDK.
 * @param {PromiseConstructor} [PromisePonyfill=window.Promise] - optional Promise Constructor ponyfill.
 * @return {Promise<Object>} paypalObject - reference to the global window PayPal object.
 */


function loadScript(options, PromisePonyfill) {
  if (PromisePonyfill === void 0) {
    PromisePonyfill = getDefaultPromiseImplementation();
  }

  validateArguments(options, PromisePonyfill); // resolve with null when running in Node

  if (typeof window === "undefined") return PromisePonyfill.resolve(null);

  var _a = processOptions(options),
      url = _a.url,
      dataAttributes = _a.dataAttributes;

  var namespace = dataAttributes["data-namespace"] || "paypal";
  var existingWindowNamespace = getPayPalWindowNamespace$1(namespace); // resolve with the existing global paypal namespace when a script with the same params already exists

  if (findScript(url, dataAttributes) && existingWindowNamespace) {
    return PromisePonyfill.resolve(existingWindowNamespace);
  }

  return loadCustomScript({
    url: url,
    attributes: dataAttributes
  }, PromisePonyfill).then(function () {
    var newWindowNamespace = getPayPalWindowNamespace$1(namespace);

    if (newWindowNamespace) {
      return newWindowNamespace;
    }

    throw new Error("The window." + namespace + " global variable is not available.");
  });
}
/**
 * Load a custom script asynchronously.
 *
 * @param {Object} options - used to set the script url and attributes.
 * @param {PromiseConstructor} [PromisePonyfill=window.Promise] - optional Promise Constructor ponyfill.
 * @return {Promise<void>} returns a promise to indicate if the script was successfully loaded.
 */


function loadCustomScript(options, PromisePonyfill) {
  if (PromisePonyfill === void 0) {
    PromisePonyfill = getDefaultPromiseImplementation();
  }

  validateArguments(options, PromisePonyfill);
  var url = options.url,
      attributes = options.attributes;

  if (typeof url !== "string" || url.length === 0) {
    throw new Error("Invalid url.");
  }

  if (typeof attributes !== "undefined" && typeof attributes !== "object") {
    throw new Error("Expected attributes to be an object.");
  }

  return new PromisePonyfill(function (resolve, reject) {
    // resolve with undefined when running in Node
    if (typeof window === "undefined") return resolve();
    insertScriptElement({
      url: url,
      attributes: attributes,
      onSuccess: function onSuccess() {
        return resolve();
      },
      onError: function onError() {
        return reject(new Error("The script \"" + url + "\" failed to load."));
      }
    });
  });
}

function getDefaultPromiseImplementation() {
  if (typeof Promise === "undefined") {
    throw new Error("Promise is undefined. To resolve the issue, use a Promise polyfill.");
  }

  return Promise;
}

function getPayPalWindowNamespace$1(namespace) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return window[namespace];
}

function validateArguments(options, PromisePonyfill) {
  if (typeof options !== "object" || options === null) {
    throw new Error("Expected an options object.");
  }

  if (typeof PromisePonyfill !== "undefined" && typeof PromisePonyfill !== "function") {
    throw new Error("Expected PromisePonyfill to be a function.");
  }
}

const SCRIPT_LOADING_STATE = {
    INITIAL: "initial",
    PENDING: "pending",
    REJECTED: "rejected",
    RESOLVED: "resolved",
};
const ScriptContext = React.createContext(null);
const ScriptDispatchContext = React.createContext(null);
function scriptReducer(state, action) {
    switch (action.type) {
        case "setLoadingStatus":
            return {
                options: {
                    ...state.options,
                },
                loadingStatus: action.value,
            };
        case "resetOptions":
            // destroy existing script to make sure only one script loads at a time
            destroySDKScript(state.options["data-react-paypal-script-id"]);
            return {
                loadingStatus: SCRIPT_LOADING_STATE.PENDING,
                options: {
                    ...action.value,
                    "data-react-paypal-script-id": `${getNewScriptID()}`,
                },
            };
        default: {
            return state;
        }
    }
}
function getNewScriptID() {
    return `react-paypal-js-${Math.random().toString(36).substring(7)}`;
}
function destroySDKScript(reactPayPalScriptID) {
    const scriptNode = document.querySelector(`script[data-react-paypal-script-id="${reactPayPalScriptID}"]`);
    if (scriptNode === null)
        return;
    if (scriptNode.parentNode) {
        scriptNode.parentNode.removeChild(scriptNode);
    }
}
function usePayPalScriptReducer() {
    const scriptContext = React.useContext(ScriptContext);
    const dispatchContext = React.useContext(ScriptDispatchContext);
    if (scriptContext === null || dispatchContext === null) {
        throw new Error("usePayPalScriptReducer must be used within a PayPalScriptProvider");
    }
    const { loadingStatus, ...restScriptContext } = scriptContext;
    const derivedStatusContext = {
        ...restScriptContext,
        isInitial: loadingStatus === SCRIPT_LOADING_STATE.INITIAL,
        isPending: loadingStatus === SCRIPT_LOADING_STATE.PENDING,
        isResolved: loadingStatus === SCRIPT_LOADING_STATE.RESOLVED,
        isRejected: loadingStatus === SCRIPT_LOADING_STATE.REJECTED,
    };
    return [derivedStatusContext, dispatchContext];
}
const PayPalScriptProvider = ({ options, children, deferLoading = false, }) => {
    const initialState = {
        options: {
            ...options,
            "data-react-paypal-script-id": `${getNewScriptID()}`,
        },
        loadingStatus: deferLoading
            ? SCRIPT_LOADING_STATE.INITIAL
            : SCRIPT_LOADING_STATE.PENDING,
    };
    const [state, dispatch] = React.useReducer(scriptReducer, initialState);
    React.useEffect(() => {
        if (deferLoading === false &&
            state.loadingStatus === SCRIPT_LOADING_STATE.INITIAL) {
            return dispatch({
                type: "setLoadingStatus",
                value: SCRIPT_LOADING_STATE.PENDING,
            });
        }
        if (state.loadingStatus !== SCRIPT_LOADING_STATE.PENDING)
            return;
        let isSubscribed = true;
        loadScript(state.options)
            .then(() => {
            if (isSubscribed) {
                dispatch({
                    type: "setLoadingStatus",
                    value: SCRIPT_LOADING_STATE.RESOLVED,
                });
            }
        })
            .catch(() => {
            if (isSubscribed) {
                dispatch({
                    type: "setLoadingStatus",
                    value: SCRIPT_LOADING_STATE.REJECTED,
                });
            }
        });
        return () => {
            isSubscribed = false;
        };
    }, [options, deferLoading, state.loadingStatus]);
    return (React__default['default'].createElement(ScriptContext.Provider, { value: state },
        React__default['default'].createElement(ScriptDispatchContext.Provider, { value: dispatch }, children)));
};

const DEFAULT_PAYPAL_NAMESPACE = "paypal";
function getPayPalWindowNamespace(namespace = DEFAULT_PAYPAL_NAMESPACE) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return window[namespace];
}

/**
 * This `<PayPalButtons />` component renders the [Smart Payment Buttons](https://developer.paypal.com/docs/business/javascript-sdk/javascript-sdk-reference/#buttons).
 * It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.
 *
 * Use props for customizing your buttons. For example, here's how you would use the `style` and `createOrder` options:
 *
 * ```jsx
 *     <PayPalButtons style={{ layout: "vertical" }} createOrder={(data, actions) => {}} />
 * ```
 */
const PayPalButtons = ({ className = "", disabled = false, children = null, forceReRender = [], ...buttonProps }) => {
    const buttonsContainerRef = React.useRef(null);
    const buttons = React.useRef(null);
    const [{ isResolved, options }] = usePayPalScriptReducer();
    const [initActions, setInitActions] = React.useState(null);
    const [isEligible, setIsEligible] = React.useState(true);
    const [, setErrorState] = React.useState(null);
    function closeButtonsComponent() {
        if (buttons.current !== null) {
            buttons.current.close().catch(() => {
                // ignore errors when closing the component
            });
        }
    }
    // useEffect hook for rendering the buttons
    React.useEffect(() => {
        // verify the sdk script has successfully loaded
        if (isResolved === false) {
            return closeButtonsComponent;
        }
        const paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]);
        // verify dependency on window object
        if (paypalWindowNamespace === undefined ||
            paypalWindowNamespace.Buttons === undefined) {
            setErrorState(() => {
                throw new Error(getErrorMessage$2(options));
            });
            return closeButtonsComponent;
        }
        const decoratedOnInit = (data, actions) => {
            setInitActions(actions);
            if (typeof buttonProps.onInit === "function") {
                buttonProps.onInit(data, actions);
            }
        };
        buttons.current = paypalWindowNamespace.Buttons({
            ...buttonProps,
            onInit: decoratedOnInit,
        });
        // only render the button when eligible
        if (buttons.current.isEligible() === false) {
            setIsEligible(false);
            return closeButtonsComponent;
        }
        if (buttonsContainerRef.current === null) {
            return closeButtonsComponent;
        }
        buttons.current.render(buttonsContainerRef.current).catch((err) => {
            // component failed to render, possibly because it was closed or destroyed.
            if (buttonsContainerRef.current === null ||
                buttonsContainerRef.current.children.length === 0) {
                // paypal buttons container is no longer in the DOM, we can safely ignore the error
                return;
            }
            // paypal buttons container is still in the DOM
            setErrorState(() => {
                throw new Error(`Failed to render <PayPalButtons /> component. ${err}`);
            });
        });
        return closeButtonsComponent;
    }, [isResolved, ...forceReRender, buttonProps.fundingSource]);
    // useEffect hook for managing disabled state
    React.useEffect(() => {
        if (initActions === null) {
            return;
        }
        if (disabled === true) {
            initActions.disable().catch(() => {
                // ignore errors when disabling the component
            });
        }
        else {
            initActions.enable().catch(() => {
                // ignore errors when enabling the component
            });
        }
    }, [disabled, initActions]);
    const isDisabledStyle = disabled ? { opacity: 0.33 } : {};
    const classNames = `${className} ${disabled ? "paypal-buttons-disabled" : ""}`.trim();
    if (isEligible === false) {
        return children;
    }
    return (React__default['default'].createElement("div", { ref: buttonsContainerRef, style: isDisabledStyle, className: classNames }));
};
function getErrorMessage$2({ components = "", "data-namespace": dataNamespace = DEFAULT_PAYPAL_NAMESPACE, }) {
    let errorMessage = `Unable to render <PayPalButtons /> because window.${dataNamespace}.Buttons is undefined.`;
    // the JS SDK includes the Buttons component by default when no 'components' are specified.
    // The 'buttons' component must be included in the 'components' list when using it with other components.
    if (components.length && !components.includes("buttons")) {
        const expectedComponents = `${components},buttons`;
        errorMessage +=
            "\nTo fix the issue, add 'buttons' to the list of components passed to the parent PayPalScriptProvider:" +
                `\n\`<PayPalScriptProvider options={{ components: '${expectedComponents}'}}>\`.`;
    }
    return errorMessage;
}

/**
 * The `<PayPalMarks />` component is used for conditionally rendering different payment options using radio buttons.
 * The [Display PayPal Buttons with other Payment Methods guide](https://developer.paypal.com/docs/business/checkout/add-capabilities/buyer-experience/#display-paypal-buttons-with-other-payment-methods) describes this style of integration in detail.
 * It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.
 *
 * ```jsx
 *     <PayPalMarks />
 * ```
 *
 * This component can also be configured to use a single funding source similar to the [standalone buttons](https://developer.paypal.com/docs/business/checkout/configure-payments/standalone-buttons/) approach.
 * A `FUNDING` object is exported by this library which has a key for every available funding source option.
 *
 * ```js
 *     import { FUNDING } from '@paypal/react-paypal-js'
 * ```
 *
 * Use this `FUNDING` constant to set the `fundingSource` prop.
 *
 * ```jsx
 *     <PayPalMarks fundingSource={FUNDING.PAYPAL}/>
 * ```
 */
const PayPalMarks = ({ className = "", ...markProps }) => {
    const [{ isResolved, options }] = usePayPalScriptReducer();
    const markContainerRef = React.useRef(null);
    const mark = React.useRef(null);
    const [, setErrorState] = React.useState(null);
    React.useEffect(() => {
        // verify the sdk script has successfully loaded
        if (isResolved === false) {
            return;
        }
        // don't rerender when already rendered
        if (mark.current !== null) {
            return;
        }
        const paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]);
        // verify dependency on window object
        if (paypalWindowNamespace === undefined ||
            paypalWindowNamespace.Marks === undefined) {
            setErrorState(() => {
                throw new Error(getErrorMessage$1(options));
            });
            return;
        }
        mark.current = paypalWindowNamespace.Marks({ ...markProps });
        // only render the mark when eligible
        if (mark.current.isEligible() === false) {
            return;
        }
        if (markContainerRef.current === null) {
            return;
        }
        mark.current.render(markContainerRef.current).catch((err) => {
            // component failed to render, possibly because it was closed or destroyed.
            if (markContainerRef.current === null ||
                markContainerRef.current.children.length === 0) {
                // paypal marks container is no longer in the DOM, we can safely ignore the error
                return;
            }
            // paypal marks container is still in the DOM
            setErrorState(() => {
                throw new Error(`Failed to render <PayPalMarks /> component. ${err}`);
            });
        });
    }, [isResolved, markProps.fundingSource]);
    return React__default['default'].createElement("div", { ref: markContainerRef, className: className });
};
function getErrorMessage$1({ components = "", "data-namespace": dataNamespace = DEFAULT_PAYPAL_NAMESPACE, }) {
    let errorMessage = `Unable to render <PayPalMarks /> because window.${dataNamespace}.Marks is undefined.`;
    // the JS SDK does not load the Marks component by default. It must be passed into the "components" query parameter.
    if (!components.includes("marks")) {
        const expectedComponents = components ? `${components},marks` : "marks";
        errorMessage +=
            "\nTo fix the issue, add 'marks' to the list of components passed to the parent PayPalScriptProvider:" +
                `\n\`<PayPalScriptProvider options={{ components: '${expectedComponents}'}}>\`.`;
    }
    return errorMessage;
}

const PayPalMessages = ({ className = "", forceReRender = [], ...messageProps }) => {
    const [{ isResolved, options }] = usePayPalScriptReducer();
    const messagesContainerRef = React.useRef(null);
    const messages = React.useRef(null);
    const [, setErrorState] = React.useState(null);
    React.useEffect(() => {
        // verify the sdk script has successfully loaded
        if (isResolved === false) {
            return;
        }
        const paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]);
        // verify dependency on window object
        if (paypalWindowNamespace === undefined ||
            paypalWindowNamespace.Messages === undefined) {
            setErrorState(() => {
                throw new Error(getErrorMessage(options));
            });
            return;
        }
        messages.current = paypalWindowNamespace.Messages({ ...messageProps });
        if (messagesContainerRef.current === null) {
            return;
        }
        messages.current.render(messagesContainerRef.current).catch((err) => {
            // component failed to render, possibly because it was closed or destroyed.
            if (messagesContainerRef.current === null ||
                messagesContainerRef.current.children.length === 0) {
                // paypal messages container is no longer in the DOM, we can safely ignore the error
                return;
            }
            // paypal messages container is still in the DOM
            setErrorState(() => {
                throw new Error(`Failed to render <PayPalMessages /> component. ${err}`);
            });
        });
    }, [isResolved, ...forceReRender]);
    return React__default['default'].createElement("div", { ref: messagesContainerRef, className: className });
};
function getErrorMessage({ components = "", "data-namespace": dataNamespace = DEFAULT_PAYPAL_NAMESPACE, }) {
    let errorMessage = `Unable to render <PayPalMessages /> because window.${dataNamespace}.Messages is undefined.`;
    // the JS SDK does not load the Messages component by default. It must be passed into the "components" query parameter.
    if (!components.includes("messages")) {
        const expectedComponents = components
            ? `${components},messages`
            : "messages";
        errorMessage +=
            "\nTo fix the issue, add 'messages' to the list of components passed to the parent PayPalScriptProvider:" +
                `\n\`<PayPalScriptProvider options={{ components: '${expectedComponents}'}}>\`.`;
    }
    return errorMessage;
}

var FUNDING = {
  PAYPAL: 'paypal',
  VENMO: 'venmo',
  APPLEPAY: 'applepay',
  ITAU: 'itau',
  CREDIT: 'credit',
  PAYLATER: 'paylater',
  CARD: 'card',
  IDEAL: 'ideal',
  SEPA: 'sepa',
  BANCONTACT: 'bancontact',
  GIROPAY: 'giropay',
  SOFORT: 'sofort',
  EPS: 'eps',
  MYBANK: 'mybank',
  P24: 'p24',
  VERKKOPANKKI: 'verkkopankki',
  PAYU: 'payu',
  BLIK: 'blik',
  TRUSTLY: 'trustly',
  ZIMPLER: 'zimpler',
  MAXIMA: 'maxima',
  OXXO: 'oxxo',
  BOLETO: 'boleto',
  WECHATPAY: 'wechatpay',
  MERCADOPAGO: 'mercadopago'
};

exports.FUNDING = FUNDING;
exports.PayPalButtons = PayPalButtons;
exports.PayPalMarks = PayPalMarks;
exports.PayPalMessages = PayPalMessages;
exports.PayPalScriptProvider = PayPalScriptProvider;
exports.usePayPalScriptReducer = usePayPalScriptReducer;
